#+startup: content logdone inlneimages

#+hugo_base_dir: ../../../
#+hugo_section: post/2022/09
#+author: derui

* DONE 初めてCDKを触ってみた                                          :AWS:TypeScript:
CLOSED: [2022-09-01 木 22:53]
:PROPERTIES:
:EXPORT_FILE_NAME: cdk_first_time
:END:
実家が秋田にあるのですが、3年振りに花火競技大会を見てきました。記憶にある限りでは初めて雨の中見ましたが、いいもんはやっぱいいもんでした。風向きだけが惜しかった。

細々となんかを作っているのですが、その過程でAWS上に環境が必要となってしまいました。そういやCDKってあったと思い出し、使ってみたのでその感想です。

#+html: <!--more-->

** CDK is 何
CDKとは、 ~Cloud Development Kit~ の略称です。今迄CloudFormationやterraformなどがありましたが、それらよりもさらにプログラマブル、というよりもプログラミング言語自体を利用して、AWS環境を構築していくことができます。

特徴としては、

- セキュアなリソースをより少ないコードで構築できる
- プログラミングのイディオムを利用してモデル化していくことができる
- アプリケーションコードまで含めて一箇所で管理できる
- TypeScriptやJavaScript、C#やGoなど、アプリケーションを開発する言語と同じ言語で利用できる


https://docs.aws.amazon.com/cdk/api/v2/

terraformは、tfという専用の言語を利用していましたが、CDKでは普通のライブラリとして提供されており、一般的に利用されるプログラミング言語をフルに利用して構築できる、ということがメリットとなっているようです。

** CDKのメリデメ
どんなものにもトレードオフがあるように、CDKにも当然ながらデメリットがあります。

- AWSのリソースしか作れない
  - ~terraform~ みたいに、datadogやGCP、Azureとかまで一箇所で・・・みたいな真似は不可能です
  - 触ってみるとわかりますが、かなり手間がかかってそうなので、terraformと同様にやっていくのは無理じゃないかなと
- 遅い
  - 一応hotswapという、APIを直接叩きまくるものはあるようです
  - が、最終的にみんな大好き ~CloudFormation~ で実行されるので、リソース作成とかがterraformと比較して多分倍くらい遅いです
- 既存の環境と別になる場合がある
  - CDKが利用しているライブラリのバージョンなどがかなり古く、アプリ自体とは全然マッチしない可能性があります
  - ライブラリ含め一箇所で・・・みたいなのは難しい場合があります

** CDKワークショップ
CDKには、 [[https://cdkworkshop.com/20-typescript.html][公式のワークショップ]]が充実しています。というかちょっとしたAPIとかなら、この内容＋型定義とかを見てたらなんとなくできてしまう感じです。

#+begin_quote
今回は、TypeScriptでやりました
#+end_quote

ワークショップの中には、resourceを新しく定義したりという、徐々に高レベルになっていくものが含まれています。CloudFormationのStackをフルに活用して、より高度化していくこともできるようです。恐らくきちんとしたサービスを、これを利用していく上ではなんぼか必要になってくるんでしょうけど、私が今やろうとしている内容だとそこまで不要でした。

** どんな感じ
ワークショップを見てもらうのが一番速いですが、こんな感じで

- Lambda
- API Gateway
- ECR
- 必要最低限のIAM


ができちゃいます。

#+begin_src typescript
  import * as cdk from "aws-cdk-lib";
  import { Construct } from "constructs";
  import * as lambda from "aws-cdk-lib/aws-lambda";
  import * as apigw from "aws-cdk-lib/aws-apigateway";

  export class CdkStack extends cdk.Stack {
    constructor(scope: Construct, id: string, props?: cdk.StackProps) {
      super(scope, id, props);

      const lambda = new lambda.DockerImageFunction(this, "lambda", {
        functionName: "test",
        code: lambda.DockerImageCode.fromImageAsset("../"),
      });

      const restApi = new apigw.LambdaRestApi(this, "Endpoint", {
        handler: lambda,
      });
    }
  }
#+end_src

CFnやterraformだと、やっぱり利用するリソースを全部定義していかないといけないため、精緻に作成することはできますが、その分とても時間がかかったり見通しが悪かったり、設定漏れなどによるセキュリティ問題などがどうしても出やすい傾向があります。CDKの標準で提供されているものを使う範囲だと、必要最小限のIAMとかしか使われないため、サクサクと作成していくことができます。


** ここがよかった

*** 差分が見やすい
terraformである程度のサイズをいじった方はわかると思いますが、diffを見るのが大分辛いです。CDKの場合、IAMの差分をテーブル形式で表示してくれるため、かなり見やすいです。実際には漸進的に作成していくと思うので、大量のリソースが・・・みたいなことはそこまでない気がします。きっと。

#+begin_example
  Stack CdkWorkshopStack
  IAM Statement Changes
  ┌───┬─────────────────────────────────┬────────┬─────────────────┬───────────────────────────┬──────────────────────────────────────────────────┐
  │   │ Resource                        │ Effect │ Action          │ Principal                 │ Condition                                        │
  ├───┼─────────────────────────────────┼────────┼─────────────────┼───────────────────────────┼──────────────────────────────────────────────────┤
  │ - │ ${CdkWorkshopQueue50D9D426.Arn} │ Allow  │ sqs:SendMessage │ Service:sns.amazonaws.com │ "ArnEquals": {                                   │
  │   │                                 │        │                 │                           │   "aws:SourceArn": "${CdkWorkshopTopicD368A42F}" │
  │   │                                 │        │                 │                           │ }                                                │
  └───┴─────────────────────────────────┴────────┴─────────────────┴───────────────────────────┴──────────────────────────────────────────────────┘
  (NOTE: There may be security-related changes not in this list. See https://github.com/aws/aws-cdk/issues/1299)

  Resources
  [-] AWS::SQS::Queue CdkWorkshopQueue50D9D426 destroy
  [-] AWS::SQS::QueuePolicy CdkWorkshopQueuePolicyAF2494A5 destroy
  [-] AWS::SNS::Topic CdkWorkshopTopicD368A42F destroy
  [-] AWS::SNS::Subscription CdkWorkshopTopicCdkWorkshopQueueSubscription88D211C7 destroy
#+end_example

(上はワークショップから抜粋。画像じゃなかったので直接リンクできませんでした)

*** テストができる
terraformでもできますが、localstackを使ったりしてテストをすることもできます。当然開発→本番というようにAWS環境でも実行しなければならないのは確定ではありますが。それでも、UTができるのはかなり安心感があるのではないでしょうか

** SAMとセットで使うのがよいのかもしれない
今回、API Gatewayを利用するためにCDKを使ってますが、API Gatewayをローカルでテストする方法としては、SAM CLIでのローカル起動くらいしかなさそうでした。

ここらへんがより充実してくるとよいと思いますが、まぁそうは言ってもAWSも使ってもらわないと商売上がったりでもあるので、なかなか難しいんだろうなーと思った次第です。

terraformをやるほどでもないライトな環境構築にCDK、使ってみてはいかがでしょうか。

* DONE CDKで構築するAPIをローカルで確認する                                            :AWS:
CLOSED: [2022-09-10 土 10:19]
:PROPERTIES:
:EXPORT_FILE_NAME: cdk_api_on_local
:END:

今年は残暑が厳しくないかもしれないので過ごしやすくていい感じですね。

前回はCDKを使い始めたという話になりましたが、今回はCDKで構成したものを、そのままローカルで動かしたいという要求に対してアプローチしてみました。

** こうやりたい
CDKはお手軽にAWSにデプロイできますが、デプロイ = お金がかかることと同義なので、できればローカルで試せるだけ試してからやりたいところです。色々調べた感じでは、アプローチとしては二通りあるようでした。

- [[https://docs.aws.amazon.com/ja_jp/serverless-application-model/latest/developerguide/serverless-sam-cli-install-linux.html][AWS SAM CLI]]を使って、 ~sam local start-api~ で立ち上げる
- [[https://github.com/localstack/localstack][localstack]]を実行先にしてcdkをデプロイする
  - 使えるリソース、使えないリソースがあるのと、AWS公式ではないので、細かいところが違ったりというリスクはあります


どっちもメリデメありますが、今回はSAM CLIでやってみました。

** SAM CLIのインストール
SAM CLIは、とりあえずローカルにインストールする必要があります。

#+begin_src bash
$ curl -LO <url>
$ unzip -d aws-sam-cli <file>
$ cd aws-sam-cli && sudo ./install
$ sam --version
#+end_src

こんなくらいでお手軽です。x86用とarm用でバイナリが分かれているので、その点だけ注意したらよさそうです。

** templateの抽出
SAM CLIは、本来はSAM = Serverless Application Modelに基づいたワークロードをサポートするためのツールなので、 ~template.yml~ というCloudFormationが要求されます。これはcdkから吐き出せるので、吐き出しときます。

#+begin_src bash
$ npx cdk synth --no-staging > template.yml
#+end_src

こうすることで、CloudFormationのファイルが作成できます。

** APIの開始
さて、ここまで来たら、SAM CLIからローカルAPIを立ててみます。

#+begin_src bash
$ sam local start-api
Mounting <function> at http://127.0.0.1:3000/{proxy+} [DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT]
Mounting <function> at http://127.0.0.1:3000/ [DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT]
You can now browse to the above endpoints to invoke your functions. You do not need to restart/reload SAM CLI while working on your functions, changes will be reflected instantly/automatically. You only need to restart SAM CLI if you update your AWS SAM template
2022-09-03 08:40:23  * Running on http://127.0.0.1:3000/ (Press CTRL+C to quit)
#+end_src

こんな感じの表示が出たら、 ~http://localhost:3000~ にアクセスしてみます・・・が。ここで問題が発生するケースがあります。多分pythonとかnodeのコードをそのまま利用している場合は普通に動くと思いますが。

** DockerLambdaFunctionを使っている場合
今回、Rustで構築したため、必然的にDockerLambdaFunctionを利用することにしています。ところが、こいつはCloudFormationの中身を見てみると、ECRのイメージを参照する作りになってます(当たり前と言えば当たり前ですが)。当然、これはAWSにデプロイしてきちんと動くことが大前提となっているものなので、そうなっていること自体には問題ありません。

が、今やりたいのはあくまでローカルで動作させることなので、なんとかしてやりたいところ。基本的には以下の手順を踏むことでできそうでした。

1. ~sam build~
2. ~sam local start-api~


debugしながら見てみると、sam local start-apiでは、functionのリソース名と同じ名前でbuildして・・・という挙動のようでした。なので、一発sam buildしてからやるととりあえず上手く動作するようです。

*** lambdaの中でのpathとアクセスするときの違い
上記の処理で動作させられるようにはなりました。が、あまりAPI Gatewayを利用しておらず、stageの概念がいまいちわかりきっていなかったため、

- curlで  ~http://localhost:3000/foo~ にアクセスする
- Lambda内のpathだと ~http://localhost:3000/prod/foo~ にアクセスしたことになる


という統合が行われており、これによって結構難易度が上がったりしました。ぶっちゃけ全然わからずログを仕込んで初めて気付いたというか。

** もっとお手軽にやりたいがとりあえずはこれで十分
API Gatewayという巨大な仕様がベースになっていたり、色々やってくれるがゆえに、最初はとっつきづらくはありました。
が、さしあたって使えるというレベルであれば、一旦構築してしまえば後はワークロードとして動作させられるかな、とは思います。が、Buildkitが利用できなかったりするため、multi-stageを利用していたりすると、cache戦略はかなり難しい印象です。

ここらへんはもうすこし調べて、効率的にしてみたいなーとは思います。

* comment Local Variables                                           :ARCHIVE:
# Local Variables:
# eval: (org-hugo-auto-export-mode)
# End:
