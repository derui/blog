#+startup: content logdone inlneimages

#+hugo_base_dir: ../
#+hugo_section: post/2024/10
#+author: derui

* DONE 改めてQEMUを使って仮想マシンを起動してみる :Linux:
CLOSED: [2024-10-05 土 16:19]
:PROPERTIES:
:EXPORT_FILE_NAME: launch-vm-with-qemu
:END:
一気に凉しくなって、いきなり着るものに困っています。極端ですな。

昔から知っていましたが、よく思い返してみると触ったこともなかったので、QEMUをきちんと触ってみました。

#+html: <!--more-->

** そもそもQEMUとは
#+begin_quote
QEMU is a generic and open source machine emulator and virtualizer.

https://www.qemu.org/docs/master/about/index.html
#+end_quote

とあるように、emulatorとvirtualizer、つまり仮想化をするためのソフトウェアです。QEMU自体はとても昔から開発されており、Windows/macOSを含めてmulti platformで展開されています。

最初はCPU emulationのために作られた、という話があるため、古今東西のCPUを指定して仮想マシンを起動することができます。


** 最初の仮想マシン
なんらかの方法でqemuをインストールしたら、とりあえずcommandを実行してみましょう。

#+begin_src shell
  $ qemu-system-x86_64
#+end_src

起動すると、Windowと共に真っ黒な画面が表示されるはずです。QEMUはdefaultではSeaBIOSというOSSのBIOS実装を利用して起動するので、マザーボードに電源だけいれた、という状態ですね。これだけだと意味がないので、なんかisoを入れてみましょう。

#+begin_src shell
  $ qemu-system-x86_64 -cdrom ubuntu.iso
#+end_src

見おぼえのあるubuntuのinstallerが起動します。なんか適当に選んでみましょう。

起動してみると、起動した瞬間にkernel panicしているはずです。QEMUは、指定がないとmemory/CPUも設定されていない（！）ので、このままでは何もできません。このあたり、大体いい感じの設定がbattery includedされている最近の風潮とは一線を画しています。

** CPUとmemoryの設定
CPUとmemoryがないとなにもできないので、追加してみましょう。

#+begin_src shell
  $ qemu-system-x86_64 -m size=4096 \
    -smp 8 \
    -cdron ubuntu.iso
#+end_src

~-m~ でmemoryの量を指定できます。基本的にMB単位での指定です。 ~-smp~ で、仮想マシンで利用するCPUの数を指定できます。

** networkの有効化
当然ですがNICなんてものは最初から入っているわけではないので、NICについても指定する必要があります。QEMUのnetworkにはuser mode networkというemulation modeがあり、大抵はこれで用が足ります。

#+begin_src shell
  # localhost:2222を22と接続する
  $ qemu-system-x86_64 \
    # network deviceを追加する
    -device virtio-net-pci,netdev=unet \
    # netdevでdeviceに対する設定を追加する
    -netdev user,id=unet,hostfwd=tcp::2222-:22 \
        -m 4096 \
        -smp 10 \
        -cdrom ubuntu.iso

#+end_src

~hostfwd~ を指定すると、port forwardingができるので、guestとSSHで繋いで～というのがお手軽にできます。設定しておくと捗りますよ。

ちなみにこの設定だけで、wgetとかcurlとかは大体動作します。ただ、pingは何もしない状態だと許可されていないので、必要ならsysfsで許可する必要があります。以下が参考になります。

https://www.qemu.org/docs/master/system/devices/net.html#using-the-user-mode-network-stack

** storageを追加する
さて、いざインストール・・・というところで、storageがないぞ？となるかと思います。storageも当然ないので、作る必要があります。

qemuに同梱されている ~qemu-img~ を利用することで、QCOW形式などQEMUで利用できるblock deviceを作製することができます。VirtualBoxなどを利用したことがある方は、 ~.qcow2~ とかの拡張子を見たことがあると思いますが、あれになります。

#+begin_src shell
  $ qemu-img create <file path> <size>

  # nixos.qcow2を10GiBのサイズで作る
  # k/m/g でそれぞれ指定できる
  # -fで指定しないとRAW formatで作られるので、指定された容量がそのまま割り当てられる
  $ qemu-img create -f qcow2 nixos.qcow2 10g

  # 利用するときは -hda などに渡すことで、block deviceとして利用できる。
  $ qemu-system-x86_64 -hda ./nixos.qcow2 
#+end_src

~-hda~ に渡すと、大抵は ~/dev/sda~ として認識されますので、あとはpartedやfdiskで料理できます。

** UEFIで起動する
さて、なにがしかをinstallしていると、最近のdistributionはUEFIでの起動が前提になっているケースが多いでしょう。そうなると、ここまでの設定だと動きません。UEFIはUEFIの設定が必要になります。

[[https://github.com/tianocore/tianocore.github.io/wiki/OVMF][OVMF]]というOSSのUEFI実装があり、これが広く使われています。これを次のように利用します。

#+begin_src shell
  # UEFIの設定変更などはここに入るので、専用にcopyしておく
  $ cp <path of ovmf/OFMV_VARS.fd .

  # UEFIはbiosではないので、 -bios オプションは利用しなくてよい
  $ qemu-system-x86_64 \
        -drive if=pflash,format=raw,file=/usr/share/edk2-ovmf/OVMF_CODE.fd,readonly=on \
        -drive if=pflash,format=raw,file=./OVMF_VARS.fd \
        -enable-kvm \
        ...args

#+end_src

OVMF.fdだったりしますので、ファイル名やパスは、ご利用のdistributionを参照下さい。 ~OFMV_VARS~ 的なファイルは、 *UEFIの設定変更* が入るため、基本的には個人毎にcopyしておくのが推奨です。

** QEMUで使い捨ての自由なemulation環境を
QEMUはKVMなども利用することで、準仮想化をすることができます。NVMeとかのemulationもできたり、GPUの利用などもできます。使ったことのないsoftwareの素振りや、完全に分離された作業環境が必要なときなどにいかがでしょう。

ちなみに、CLIからやるのは一般的ではないので、大抵はvirt-managerとかから利用することになります（私は使ってないですが）。

さて、いきなりなんでこんな記事を書いたのかというと、次の記事へ繋げるため、という感じになります。

* DONE NixOSに入門してみた :Linux:
CLOSED: [2024-10-13 日 11:13]
:PROPERTIES:
:EXPORT_FILE_NAME: nixos-starter
:END:

一気に凉しくなって、いきなり着るものに困っています。極端ですな(２回目)。


最近PCを新調しまして、そのなかでNixOSに興味がでたので入門してみました。

#+html: <!--more-->

** NixOSとは
https://nixos.org/

トップページにどーんと書いていますが、

#+begin_quote
Declarative builds and deployments.
#+end_quote

を実現することを目的としたLinux distributionです。技術的には、Nixというbuild tool及び同名のDSLを利用して、 **OS全体を宣言的にしてやろう** という、かなり狂気を感じる方法を取っています。

#+begin_quote
Nix is a tool that takes a unique approach to package management and system configuration. Learn how to make reproducible, declarative and reliable systems. 
#+end_quote

実際進めていくと、色々理想と現実とのGapが見えてきそうなのはやる前からわかってましたが、純粋関数型のbuild、と聞くと、日頃ビルドに苦しめられている開発者としては琴線に触れるものではないでしょうか。

installにあたっては、すでに色々と地雷を踏んでいただいている先人の資料を参考にさせていただきました。NixOSは、 **準備が足りないと何もできない** ってのは本当だったので、事前に仮想マシンで構築できるかどうかを検証したほうがよいです。
https://zenn.dev/asa1984/articles/nixos-is-the-best

** Nixとその周辺ツール
Nixが全体を構成する最重要ツールですが、Nix周辺のエコシステムでは、他にも重要なツール・拡張機能が存在しています。

- Flakes
- Home Manager
  - https://nix-community.github.io/home-manager/


大きく書くとこの２つになります。Flakesはnix自体の拡張、Home Managerはコミュニティ主導でのツールになります。詳しい使い方とかは公式を見ていただくのがよいかなと。

特にnixは、それぞれ全く構成が異なるため、manualがあっても試行錯誤が前提となっています。

** NixOSのインストール
https://nixos.org/manual/nixos/stable/#sec-installation

に従ってやりましょう。なお、私はGentooのときからの癖で、minimal installationを常時選択しています。Gentooと比べると、最初にKernel configurationがないだけ大分楽やなぁ、と思ってしまうくらいには楽ですね。

正直インストールは単なる準備で、rebootしてからが本当のinstallになります。ここまでで事前にnixの構成を作っていない場合は、rebootしてしまうと何もできないので、できるだけここで完了させておくことを推奨します。

*** インストールするときにflakesを利用する
すでにGitHubとかに上げてあり、かつFlakesを利用している場合、以下のようにしてFlakeから直接インストールすることができます。

#+begin_src shell
  $ nixos-install --root /mnt --flake "github:<owner>/<repo>#<config>"
#+end_src

** Nixとの戦い
NixOSは、 *なにか変更したい* == Nixの編集、となります。そのため、Nix言語及びツールへの習熟は嫌でも高まるという、いいんだか悪いんだか、というループが構成されています。

ただ、前述したように、NixOSの設定構成は千者万別ですので、基本的には断片をなんとなく理解して、自分の設定に当てはめていく、という厳しい作業が必要になります。

https://github.com/derui/my-nixos

私のNixOSの設定はすべてここにあります。適宜コメントなどは入れていますので、参考になれば。

*** 大事なこと
https://search.nixos.org/

何も言わずにこのサイトをbookmarkしましょう。option/packageを探すときに最初に見る場所になります。・・・とはいえ、結局よくわからなくてsourceを見る機会も多いのですが。

*** Emacsとかの管理
home-managerを導入していると、EmacsなどのDotfilesもNixでまとめて管理することができます。他のリポジトリで管理しつつFlakeとして取得する・・・ということもできますので、ここは好みかなと。

私は全部一個にぶち込みたい人なので、まとめて管理しています。管理する中でTipsなどもできたのですが、ここはまた別の機会に。


** とりあえず入門できました
今この記事は、新マシンにインストールしたNixOS上で書いています。実はsystemdを利用したシステムは宗教上の理由で利用していなかったのですが、利用するだけならやっぱり楽だよねえ、というのは実感してます。

ただその分、blackboxが大きすぎることの不安は変わらないので、ここはNixで管理できるというところがありがたいです。以前のGentooだと、基本的に再現を諦めるOr秘伝のタレ状態を引き継ぎ続ける、ってなってたので。

けして万人に進められるようなディストリビューションではないですが、設定ファイルだけなんとかしたい、みたいなときにも対応はできるので、Nixだけでも見てみてはいかがでしょうか。

個人的には、Haskellとかで苦しんだ経験があれば、Nixも多少は理解しやすいかな、と思います。動的に色々変わるのでマジわからなくなるのは困りものですが。

* comment Local Variables                                           :ARCHIVE:
# Local Variables:
# eval: (org-hugo-auto-export-mode)
# End:

