#+startup: content logdone inlneimages

#+hugo_base_dir: ../../../
#+hugo_auto_set_lastmod: t
#+HUGO_SECTION: post/2021/10
#+AUTHOR: derui

* DONE デスク環境を更新した                                            :雑記:
CLOSED: [2021-10-09 土 10:41]
:PROPERTIES:
:EXPORT_FILE_NAME: update_desk_environment
:END:
10月になっても半袖で十分というのはどうなんだ、と思いつつ、でもようやく涼しくなるようになってきました。

リモートワークでも生活でもずーっと使っているデスク環境を更新したので、その話を書こうかと思います。

<!--more-->

** 元々のデスク環境
さて、そもそも以前のデスクはどんな感じだったのかというと。

[[file:resized_before_desk_environment.jpg]]

こんな感じでした.これは実際にデスク周りを変更する直前なのでディスプレイとかは電源切ってます。


このデスクのスペックとデスクの上にあったものとして、

- デスク( ~幅160cm x 奥行60cm x 高さ70cm~ )
- ディスプレイ2枚
  - 27inch
- デスクトップスピーカー
- キーボード
- トラックボール
- コントローラー2個
- PS5
- ちょっとした物いれ


がありました。PS5は右のディスプレイの影になってますね。左端にちょこっと見えてる台みたいなやつは、デスクトップPCのキャリアです。

** 前の構成の課題
このデスクは前の部屋でも使っていたものを持ってきたやつですが、新しい部屋で使ううちに色々課題が生まれてきました。

- 左側のデッドスペースが気になる
  - デスクトップを入れているキャリアは、その上部空間がまるごと無駄になってます
- ゲームのコントローラーをしまう場所が無い
  - 別にいいんですが、いつまでも剥き出しというのも・・・
  - というかこのデスクは仕事でも使うので、これはこれでどうなん？という
- 上下のスペースが活用できていない
  - デスクの幅が160cmあるので、特に右側とかは上部に隙間がないという感じになってます。


これらの課題をどうしようかな、と考えてみました。

- デスクの幅が広すぎるので、もうちょっと狭くしても問題ない
  - 逆に、奥行がもうちょっとあってもよいかな、という考えにもなりました
  - iPadが置いてある辺に、通常はノートPCが置いてあるので、若干奥行が微妙だったりします
- 右にあるディスプレイをPC台の上に持っていく
  - 地震があったりするとちょっと怖いですが、エルゴトロンを信じて
- サイドデスク的なもので上下のスペースを活用する
  - PS5とかをデスクの上に載せないで、別に載せる感じで


後、デスクはまだリモートワークが続きそうでもある & 生活のほぼすべてがこの周辺なので、立ちながらとかできるように、電動昇降デスクを検討しました。
** 劇的After
さて、とりあえず更新してみました。

[[file:resized_after_desk_environment.jpg]]

ジャーン。ちなみにこれはまだ配置を調整している最中なので、現在はもうちょっと調整されてます。


更新ポイントは以下のような感じです。

- 憧れの電動昇降デスクにした
- サブデスクを導入した
- ディスプレイの配置を変更した
- スピーカーの位置を調整した


電動昇降デスクとサブデスクは↓にしました。サブデスクというかメタルラックなんですけど、ちょうどいいやつがこれくらいしかなかったんです。

デスクは、調べてみるとFlexiSpotを利用している・・・というのがかなり多かったので、最初はそれを検討してました。しかし、それらの記事をよく読むと、半分くらいが *FlexiSpotから提供を受けている* ということがわかりました。

これはマーケティングの一環として行われていることだとは思いますので、それ自体はよいのですが、実際それ以外のレビューを見ていると、サポートとかに課題がありそうだった & とてもいいお値段がするので、ちょっとどうしようかなぁ・・・、となってしまいました。

結局は、同等の機能があって一応国内メーカーである [[https://www.yamazen.co.jp/][山善]] 製のものを選択しました。

#+begin_quote
デスク全部合わせても椅子より安いんですけどね
#+end_quote

#+begin_export html
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=derui09-22&language=ja_JP&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=B077XC2VWH&linkId=217c9593ab5bae51716d4ebaa6363e9b"></iframe>
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=derui09-22&language=ja_JP&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=B082V8WYQS&linkId=a499c5936000a951845190498b9161c2"></iframe>
#+end_export

ちなみに電動昇降デスクは、大人二人で1時間〜1時間半くらいかかる、ということでしたが、実際に大人一人でやってみたところ、始めたのを若干後悔するくらい時間がかかりました。腰をやらなくてよかったです。

** で、どうなの？
まだ移行してから1日しか経過していませんが、左にあるマイクスタンドさえなんとかなれば・・・という感じです。現状ここ以外に置けないのですが、ここにあると左側のディスプレイがちょっと見えないんだけど・・・となってしまってます。

電動昇降デスクは、まだ数回しか昇降させてませんが、現状では特に問題なくきちんと動いています。立ちながら仕事、みたいなのは以前もやったことがありますが、立って仕事すると腕とキーボードがいい感じになるので、腕の疲れが若干軽減されますね。

** 定期的な見直しを
デスクというのは、プログラマーにとっては文字通り仕事に直結するものなので、やはり定期的な見直しは必要ですね。

でも電動昇降デスクを一人で組み立てるのは二度とやりません。超疲れた。

* DONE GraphQL + Kotlin + SpringBootの構成を試してみた(graphql-spring-boot-starter) :Kotlin:
CLOSED: [2021-10-24 日 11:56]
:PROPERTIES:
:EXPORT_FILE_NAME: graphql_kotlin_springboot_with_graphql-spring-boot-starter
:END:
仕事の方で、GraphQLをちょっと検討しだした + 個人的にも興味は持っていたので、本格的に触ってみることにしました。

GraphQLをKotlin + SpringBootで利用する方法としては、大きく三つありそうです。

- [[https://www.graphql-java-kickstart.com/spring-boot/][graphql-java-kickstar]]
- [[https://netflixtechblog.com/open-sourcing-the-netflix-domain-graph-service-framework-graphql-for-spring-boot-92b9dcecda18][Domain Graph Service]]
- [[https://docs.spring.io/spring-graphql/docs/current-SNAPSHOT/reference/html][Spring GraphQL]]


の三つがありそうです。どれもコアとしてはgraphql-javaを利用しているため、どのように統合するか？が焦点になっていますね。

#+begin_quote
Spring GraphQLは、記事の時点(2021/10)では1.0にむけてのマイルストーンを粛々と実装している、という状態です
#+end_quote

今回は、graphql-spring-boot-starterを利用してみた感想をば。なお、そもそもGraphQLとは？については、 [[https://graphql.org/][公式サイト]]を見ましょう。

<!--more-->

** セットアップ
さて、まずはセットアップ・・・なんですが、実はこのセットアップが大分苦戦しました。なぜかというと、2021/10時点で検索できる記事だと、結構古いパッケージ構造になっているケースが多く、色々動かない・・・というのがあったためです。

現状、

- graphql-java-tools
- graphql-spring-boot-starter
- graphql-java-servlet


といった関連は、すべて ~graphql-java-kickstart~ というGitHub Organizationにまとめられているので、こっちを使うのが第一になるかと。

#+begin_src text
  plugins {
      id("org.springframework.boot")
  }
  apply(plugin = "io.spring.dependency-management")
  
  dependencies {
      implementation("org.springframework.boot:spring-boot-starter-web")
      implementation("com.graphql-java-kickstart:graphql-spring-boot-starter:12.0.0")
      implementation("com.graphql-java-kickstart:graphql-java-tools:12.0.0")
  }
  
#+end_src

最小構成だと↑のような感じになります。バージョンなどはよしなに。

** schemaとのマッピング
graphql-java-toolsを利用するかしないか、で大分書きかたが異なりますが、基本的にはgraphql-spring-boot-starterを利用する場合は併用しておいた方がよさそうです。

GitHubにも書いていますが、必要なら↓のようなpropertiesを追記します。

#+begin_src text
  graphql:
    tools:
      schema-location-pattern: "**/*.graphqls"
      # Enable or disable the introspection query. Disabling it puts your server in contravention of the GraphQL
      # specification and expectations of most clients, so use this option with caution
      introspection-enabled: true
#+end_src

さて、マッピングについてはgraphql-java-toolsに準ずるので、Queryに関しては結構シンプルに書くことができます。

- ~GraphQLQueryResolver~ を実装する
  - これはRoot Queryに相当
- ~GraphQLResolver<Data>~ を実装する
  - ~Data~ のクラスに対応するResolverを実装する


という感じです。基本的にはGraphQLのschemaと名前が一致している必要があり、それを基本的に変更することはできません。
これはSpring GraphQLでも基本的に同じような路線(向こうはどっちかというとアノテーションベースですが)のようです。

*** サンプル
以下のようなGraphQLのschemaがあった場合、

#+begin_src graphql
  type Query {
    messages: [Message!]!
  }
  
  type Message {
    id: ID!
    message: String!
  }
#+end_src

以下のようなResolverでマッピングできます。

#+begin_src kotlin
  data class Message(val id: String, val message: String)
  
  class Query: GraphQLQueryResolver {
    fun messages(): List<Messaage> {
      return emptyList()
    }
  }
#+end_src

emptyListのあたりは如何様にでもできます。このResolverを実装したら、これをSchemaParserというクラスに渡す必要があります。


#+begin_src kotlin
  @SpringBootApplication
  class GraphqlApp {
  
      @Bean
      fun schemaParser(): SchemaParser {
          return SchemaParser.newParser()
              .files("sample.graphqls")
              .resolvers(Query())
              .build()
      }
  }
  
  fun main(args: Array<String>) {
      SpringApplication.run(GraphqlApp::class.java, *args)
  }
#+end_src

このようにすることで、 ~/graphql~ エンドポイントからアクセスすることができます。

** カスタムコンテキスト
graphql-javaにはGraphQLContextという形で、DataFetcher(graphql-javaが提供しているデータ取得の仕組み)からコンテキストを取得することができます。

例えば認証したユーザーの情報とかを使いたい場合、このコンテキストに渡すことで、そのリクエスト全体で利用することができます。

まず、カスタムコンテキストですが、推奨されている方法としては ~GraphQLContext::put~ などで設定して利用する、という形です。このGraphQLContextに設定するタイミングは、 ExecutionInputという実行処理に対する入力を生成するタイミングとなっています。

graphql-java-toolsでも https://www.graphql-java-kickstart.com/tools/schema-parser-options/ でそのように記載しています。

・・・が、現時点のgraphql-spring-boot-starterではちょっとここに課題があります。

graphql-java-servletで提供している仕組みとして、 ~GraphQLServletContextBuilder~ というものがあります。これは、GraphQLContextインターフェース(とてつもなくややこしいですが、こっちはgraphql-javaのGraphQLContextとは別物です)を実装したコンテキストをこのBuilderから返すことで、GraphQLContextに渡せる・・・というように読めます。

#+begin_src kotlin
  class MockContext(
      dataLoaderRegistry: DataLoaderRegistry? = null,
  ) : GraphQLContext {
      private val dataLoaderRegistry = dataLoaderRegistry ?: DataLoaderRegistry()
  
      fun bark() = "foo"
  
      override fun getSubject(): Optional<Subject> {
          return Optional.empty()
      }
  
      override fun getDataLoaderRegistry(): DataLoaderRegistry {
          return dataLoaderRegistry
      }
  }
  
  @Component
  class CoreGraphQLServletContextBuilder(
      private val companyService: CompanyService
  ) : GraphQLServletContextBuilder {
      override fun build(
          httpServletRequest: HttpServletRequest,
          httpServletResponse: HttpServletResponse
      ): GraphQLContext {
          return MockContext()
      }
  
      override fun build(session: Session?, handshakeRequest: HandshakeRequest?): GraphQLContext {
          TODO("Not yet implemented")
      }
  
      override fun build(): GraphQLContext {
          return MockContext()
      }
  }
  
#+end_src

こいつは ~graphql-spring-boot-starter~ のautoconfigureから拾われて利用される・・・んですが、ここで生成されたcontextは、 *GraphQLContext::getから取得できません* 。
ではどこから取得するのかというと、 ~DataFetchingEnvironment::getContext~ が、返却したcontextそのものになっています。

しかし、この ~DataFetchingEnvironment::getContext~ 自体が最新のgraphql-javaではdeprecatedになっており、かつgraphql-java-toolsでも警告を出すような処理になっています。

#+begin_quote
試していたときに、なんでここで取れないんだろう・・・ってしばらくデバッグやソースを読んだりしてました
#+end_quote

コミュニティ的に完全にリソースが足りていないので、中々是正が大変そうですが・・・。

** GraphQLをテストする
graphql-spring-boot-starterでは、 [[https://github.com/graphql/graphiql][graphiql]]を組み込みで利用できる・・・んですが、組み込み先のプロジェクトの設定とかと素敵にバッティングすると、利用するまでがとてつもなく長くなったりします。

手っ取り早い方法としてgraphiqlのElectron版があるので、これを利用すればとりあえずしのげます。

GraphQLは細かいDataFetcherなどを統合していく・・・という形になっているので、基本的にはこれらの単体をテストしていけばよさそうかなーとは思っています。

** 他のライブラリも試したい
まだ本当にPoC的に触っただけなので、これ以上書けることが無いという。

graphql-java-toolsが若干の前提にはなりますが、CoCに従って実装するというのはわりとわかりやすく、またマッピングについてはきちんとドキュメントに書いているので、単純に書く分には結構問題ありません。

が、バラバラのlibraryを統合している都合上、どこかチグハグ感もあります。しかし、関連ライブラリでは最も広く利用されているので、最初に選択肢として選ぶには問題ないと思います。

ちょっと次はNetflixのDGSを利用してみようかなー、と思います。

* DONE Parcel2.0を試してみた                                     :JavaScript:
CLOSED: [2021-10-31 日 08:53]
:PROPERTIES:
:EXPORT_FILE_NAME: parcel_2_0
:END:
気付いたら10月も終わりです。もう今年も残りは二ヶ月ということで、月日の流れは本当に速い。

さて、先日登場したParcel2.0を個人のプロダクトで試してみたので、それについてライトに書いてみます。

<!--more-->

** Parcelとは
まず[[https://parceljs.org/][parcel]]とはなにか・・・ということですが、こちらについては公式ページを見てもらうのが一番早いです。あえてまとめるとすると

- out of the boxで動作するbundler
- dev server/hot reloadingなどが組み込み済
- CSS/XML/JSONなどのbundleも組み込み済
- minificationやimage optimizationなども実現
- Rustで構築されているため、マルチコア利用かつ高速


という特徴があります。特にRustで構築されているということと、後述するようにtype checkingを省いているため、特にTypeScriptのビルドおよびbundleは特筆すべき速度です。

** parcelで動かすようにしてみる
https://github.com/derui/simple-planning-poker

犠牲となるのはこのリポジトリになります。元の構成はWebpack5でゼロから構築したものになります。

#+begin_quote
個人開発では、create-react-appとかNext.jsとかはあんまり使いたくない派閥です
#+end_quote

https://github.com/derui/simple-planning-poker/tree/parcel
で、parcel化したものがこれになります。

parcelは、各種ツール(組み込まれているものに限る)の設定ファイルは自動的に読み込んでくれるので、設定ファイル群はそのまま残っています。

具体的な手順は以下のようになりました。

1. ~yarn add -D parcel @parcel/transformer-typescript-tsc tsc~
2. postcss.config.jsとかのJavaScriptで記述されていた設定をJSONに移行
3. TypeScriptと、tsconfig.jsonでpathsを利用していた場合、path設定を書き換える
4. package.jsonのsourceでルートになるファイルを設定する
5. webpackの利用をやめる


*** TypeScriptを利用している場合の注意点
TypeScriptを利用しているとき、importでめっちゃ ~../~ のような相対パス表記が出るのを防ぐため、 ~paths~ に以下のような設定をしている場合があると思います。

#+begin_src js
  {
    ...,
    basePath: "./",
    paths: {
      "@/*": ["src/ts/*"]
    }
  }
#+end_src

実はこの挙動ですが、TypeScriptのオリジナルコンパイラにおける独自拡張であり、Parcelでは動作しません。

parcel2.0のドキュメントではこのあたりの記述が存在しており、基本的には↓のような記述にする必要があります。

#+begin_src js
  {
    ...,
    basePath: ".",
    paths: {
      "~*": ["./*"]
    }
  }
#+end_src

こうしないと、bundle時に超大量のエラーが出て涙することになります。

** 実際JSによる設定レスでいけたのか？
結果としては、若干書き換えは必要でしたが、 *JSでの設定レス* でビルドできることは確認しました。postcssとかeslintの設定に関しては、デフォルトの挙動で構わないのであれば、本当に設定レスで動かすことができるでしょう。

ただし、JSONベースというのは静的に決定されているものであるため、例えば production ビルドの場合は・・・というような置き換えは、Parcelの範囲ではなくソースの中に書き加える必要があります。

#+begin_quote
個人的にはこのへん、 ~#ifdef~ とかと大体一緒やなぁ、と思いました
#+end_quote

https://github.com/derui/simple-planning-poker/commit/5db2a4cb07d31c7a137fd14c9a57efd9292c595f#diff-32808ca7db8d5096c1eba4e5252db4715120f43417e1fcf4b869674d49e76a70

↑のところが実例ですが、ビルド先の環境毎に変更したいというような場合は、自分でNODE_ENVを見てやる必要があります。

** 速度はどうだった？
bundle速度については、minificationを含まないビルドについては、おおよそ10倍を超える速度でビルドができました。

minificationを含む場合は、どうしても途中で直列になってしまうので若干開発時よりは遅いですが、それでも倍以上の速度でビルドできています。フィードバックループが非常に短くなるのは確実で、開発体験としてもスムーズです。

** Parcelに課題はないの？
あります。特にTypeScriptでは、[[https://swc.rs/][swc]]と同様にtranspileのみを実施しているという都合上、ビルド時のtype checkingは行いません。だからくっそ速いのですが。

#+begin_quote
意見的には、開発時にLSPとかでtype checkingしているだろう、というのもありましたが、複数人での開発とかを考えると、絶対にCIでtype checkingを流すというのは必要だと思います
#+end_quote

また、Parcelは *プロダクションビルド* や *開発のdev server* は提供してくれますが、テストに関しては完全にノータッチです。そのため、例えばJest + TypeScriptとかを利用する場合は、自分で設定を行う必要があります。

** まとめる
- Parcel2.0は確かに超高速
- *メインの開発* については非常にやりやすい
- ただし、テストのサポートがなかったり、プロダクションでのtype checkingなどを導入する必要がある


という感じかなぁ、と思います。個人開発とかでとりあえずサクッと実装したりする、というケースには非常にマッチすると思いますし、create-react-appやNext.jsみたいなもののバックエンドとして使われる、というのがあるあるなのかな、という感触です。

ただ、transpileだけするというやつは、非常に複雑になったTypeScriptのtype checkingによるビルド速度の低下に対するカウンターパンチになるので、試したことがない場合は試してみると、考えかたが変わるかもしれません。

#+begin_quote
これもまた、考えとしては動的型付言語と静的型付言語の揺り戻しをまた見ている感じではあるのですが
#+end_quote

個人的には、webpackとかで開発環境をミニマムに構築したりする、というのが好きなので、ちょっと味気ない感じもありますが。

* comment Local Variables                                           :ARCHIVE:
# Local Variables:
# eval: (org-hugo-auto-export-mode)
# End:
