#+STARTUP: content logdone inlneimages

#+HUGO_BASE_DIR: ../../../
#+HUGO_AUTO_SET_LASTMOD: t

* Posts
:PROPERTIES:
:EXPORT_HUGO_SECTION: post/2019/05
:END:

** DONE KotlinでAPIサーバーとバッチを書いてみた感想                 :Kotlin:
CLOSED: [2019-05-02 木 09:29]
:PROPERTIES:
:EXPORT_FILE_NAME: kotlin_impressions
:EXPORT_AUTHOR: derui
:END:

去年の12月くらいから、KotlinでAPIサーバーとバッチを含むアプリケーションを業務で作っていました。その感想を書いていきます。

<!--more-->

本題の前に閑話を。世間から１週遅れくらいで、 [[https://www.sekiro.jp/][SEKIRO -SHADOWS DIE TWICE-]] をプレイしており、この間一周目が終わりました。私は一周目では攻略サイト等は見ないことにしているので、クリアと同時に解禁してみた所、一周目で出したエンドがなかなか厳しい（他のルートより短く、アイテムとかが集まりきらない）ものだと発覚・・・。
若干バッドっぽい選択肢ではあったんですが、まさかそういったものだとは思わず。おかげで二週目が厳しいものとなっております。

複数周回がありそうな選択肢だと、バッドっぽいのから選択する癖があるんですが、それが仇となりました。まぁ、二週目を進めている感じ、明らかにPlayer Skillが高まっており、思ったよりも苦戦はしていないのですが。

閑話休題。

*** 環境の前提
今回作ったアプリケーションは、既存のアプリケーションの完全作り直しなんですが、肝心の既存アプリケーションが *PL/SQL* で出来ており、完全新規に当たっては DDD を試験的に取り入れています。

**** Middleware/Framework
利用しているMiddleware/Frameworkは次のような感じです。

- Spring Boot
  - 言わずと知れた。
- Spring Batch
  - バッチを作成する必要があったので
- MySQL
  - 現場ではだいたいこれのようでした。
- Kotlin
  - 今回の主役
- jOOQ
  - ORM。Oracleに接続する場合はcommercial licenceが必要なので注意（繋げなかった人）
- Gradle
  - 大分こっちを選ぶ人が増えた印象



**** アーキテクチャ
[[https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html][Clean Architecture]] とDDDを併用しています。Clean Architectureは、とりあえず原典に従って分割している感じですが、現状あまり困っていないです。ここについてもいつか書ければ。

**** プロジェクト構成
Gradleのmulti project構成を利用して、DomainやGatewayなどの依存方向を強制しています。DDDを実践する上で、Domainに余計な依存を入れないことが重要だと思っているので、これは結構おすすめです。プロジェクトは次のように分割しています。

- domain
- usecase
- api
- batch
- infrastructure


依存関係は以下のようになっています。domainプロジェクトは、 *test以外に外部依存ライブラリがない* という状態になっています。
#+BEGIN_SRC
domain <-- usecase <- api
        └- batch
#+END_SRC

**** Kotlinの適用範囲
*全部* です。設定がめんどくさくてJavaになっているものも１ファイルくらいありますが、99.9% Kotlinで書いています。


*** Kotlin + SpringBootの感想
感想と言っても特筆すべきものはなく、あえて言えば *普通* です。Spring自体がKotlin対応を行っているということもあり、実に普通な書き心地です。

ただ、DIをしまくる関係上、関数で済むようなものでもinterfaceにしないといけないので、その点がストレスです。

#+BEGIN_SRC kotlin
@Component
class Foo(private val bar: () -> String) {
  fun exec() = bar() + "test"
}
#+END_SRC
みたいなクラスがあったとき、関数をDIすることが出来ない（多分）ので、わざわざinterfaceを定義する必要があります。

まぁ、interface定義自体は難しくないし、Javaから入った人もわかりやすいのでいいかと。ただ、関数がfirst classである、というkotlinの特徴を殺してしまいやすいのでなんともですが・・・。

*** 書いていて課題になったところ

**** Kotlin内でのSAM変換が効かない
色々なところで書かれていますが、Kotlinでは *Kotlinで定義されたinterfaceについては* SAM変換が効きません。([[https://dev.classmethod.jp/smartphone/kotlin-everyday-12/][参考]])

関数を引数に取った場合は、当然ながらLambdaを渡せるのですが、interfaceを受け取る場合はその限りではありません。これがJavaのinterfaceでもできない、というのであればある意味一貫性があると思うのですが、 *Javaで定義されたinterfaceではできる* というのもあり、うーん、という感じです。
恐らく、Javaとの100%相互運用性、という点から出来るようになっていると思うんですが・・・。

毎回object式で書くのも、かつての無名クラスを思い出すし、冗長な記述になるので、是非できるようになっていただきたい。

**** Sealed Classの使い勝手が微妙
Kotlinの [[https://kotlinlang.org/docs/reference/sealed-classes.html][sealed class]] は、代数型データ型的な扱いをする時に役立つのですが、主にIDE（IntelliJ）側で起こる問題が厄介です。

#+BEGIN_SRC kotlin
sealed class A {
  object B: A()
  data class C(val foo: Int): A()
}

fun check(v:A): Bool =
  when (v) {
    is B -> true
    is C -> false
  }
#+END_SRC
こんなソースがあったとして、 =is <クラス>= の部分で、Aの派生クラスがtopに出てこないという問題が発生します。

- whenのis句は、あくまで *smart castをしているだけ* です。([[https://kotlinlang.org/docs/reference/control-flow.html#when-expression][公式サイト]])
- なので、kotlinとしてはその後に派生クラスだけしか来ない、という判断が難しいのでしょう
- しかし、アプリケーション全体のサイズが増えてくると、探すだけで面倒ですので、出来れば出来て欲しい
- 実際、whenにsealed classが渡された時、派生クラスの一部しか指定していない場合はコンパイルエラーになるので、出来ないわけではなさそう


enum classではちゃんと出てくるのと、sealed classを継承したobjectだとちゃんと出てくるので、 *値かどうか* が重要な感じっぽいです。設定でなんとかなるのであればいいんですが・・・。OCamlの利用者がmatch文と同じようなもんだと思って使うと痛い目みます。（自分）


**** data classとfactory
DDDをKotlinでやろうとすると、間違いなくdata classの恩恵を授かると思います。ただ、data classには一つ問題があり、内部状態を変更できてしまう、という課題があります。これはdata classを単にequals/toString/hashCode等々の自動生成をしてくれる機能、としかみていない弊害のような気もしますが・・・。

#+BEGIN_SRC kotlin
data class Foo(val a: Int, private val b: Int) {
}

val a = Foo()
a.b = 100 // エラー。
val c = a.copy(b = 100) // OK!
#+END_SRC
これは、data classがPOJO的なobjectのコピー生成を簡便にするためのcopyメソッドを生成するためです。本来の目的としては正しいのですが、これを使ってしまうと意味がないのです・・・。

また、private fieldもコンストラクタに書かないといけないので、結局内部構造を露呈しているのと変わりません。factoryを用意しても、copyで書き換えられます。

これを回避したければ、interfaceとの併せ技を利用する必要があります。

#+BEGIN_SRC kotlin
interface Foo {
  val a: Int

  fun exec(): Int

  companion object {
    fun create(v: Int): Foo = FooImpl(v)
  }
}

private data class FooImpl(override val a: Int) {
  private val b: Int

  init {
    b = a * 2
  }

  override fun exec() = b
}

// 別ファイル
val v = Foo.create(100)
v.b // エラー
v.copy // 定義されていない
v.exec() // 200
#+END_SRC

正直めんどくさいのですが、Kotlinは単一ファイルに複数の定義をすることが出来るので、見通し自体はそんなに悪くありません。interfaceだと外部で実装される可能性があり、それも排除したいのであれば、sealed classにするのも手でしょう。テストがめんどくさくなる気はしますが。

*** でもkotlinはいいぞ
使っていくうちに不満が溜まっていくのは、どんなものでもそうだと思うので仕方ないと思いますが、個人的にkotlinはかなり気に入っています。特に次の部分がお気に入りです。

- data classでお手軽なDTO作成
  - lombokのインストール周りで戦う必要なし
- sealed classで擬似的な代数型
  - メソッドの結果を返すようなところに絞って利用しています
- 同一ファイルでの複数定義
  - なんだかんだ言いつつ、関連性の高いものを一箇所にまとめられるというのはいいものです


Java本体の機能拡充も続いていますが、まだしばらくはKotlinを続けていこうかと思います。

** DONE SEKIRO -SHADOWS DIE TWICE- の感想                         :Game:雑記:
CLOSED: [2019-05-22 水 13:17]
:PROPERTIES:
:EXPORT_FILE_NAME: game_review_sekiro
:EXPORT_AUTHOR: derui
:END:

せっかくの個人ブログなのでこんなものも書いてみます。レビューというか感想ですね。

<!--more-->

[[https://www.sekiro.jp/][SEKIRO -SHADOWS DIE TWICE-]] （PS4版。以下SEKIRO）のプラチナトロフィー取得が終わったので、感想を書いてみます。完全に個人的な感想ですので、仮にこれを読んで買って満足できなかったとしても保証はできかねます。ご了承を。

なお、完全にプラチナ狙いで行ったので、3週目で終了しています。

*** 書いている人間のスペック
前提として、この記事を書いている人間のゲーム的スペックを書いておきます。ライトではないがガチでもない、という普通の領域だと思います。

- Demon's Soul/Dark Soul(1のみ)/Bloodborneクリア経験あり
- 基本PS4/PCのゲームが主
- やり込むというよりはトロフィー狙いが多い
- 最初の一周は一切攻略サイトとかを見ない、がポリシー

*** どんなゲーム？
*死ぬことを楽しむゲームです*

なんの説明にもなっていないですね。ちゃんとした紹介は↑の更新サイトを見たほうが早いと思います。Demon's Soul/Dark SoulやBloodborneをプレイしたことがある方であれば、ああいう感じ、と言えば伝わるでしょうか。SIEとFROM Softwareが手を組んだ作品です。ちなみに =SEKIRO= は *せきろ* と読むのが公式だそうです・・・ほんとか？

すっかりSoulライクゲームがFROM Softwareの代名詞になりましたが、30代くらいの人にとっては =FROM Software＝アーマードコア= とかなんじゃないでしょうか。もうアーマードコアが出ることはなさそうですが、もう一回プレイしてみたいものです。

閑話休題。

さて、Soulライクゲームと同じような感じ、と書きましたが、その内容は大きく異なります。同じなのは死んで覚える、というくらいです。私は最初の一周は公式サイト以外を見ないことにしているので、死にっぷりに拍車がかかります・・・。が、できればSEKIROやSoulライクゲームは最初だけは攻略サイトとかを見ないようにするのをおすすめしたいです。
そのあたりは個人の裁量なので、最初からガッツリ見るも詰まったら見るも自由ですが。

*** SEKIROとSoulライクゲームの違い
簡単に箇条書していきます。

- レベル概念の撤廃
  - Dark Soulとかでは、キャラクターの成長自体が個性になりますが、SEKIROでは成長要素は2つしかありません
  - また、大抵のスキルは *プレイを楽にする* のではなく、 *多様な攻略* を可能にするものなので、これを取ると楽になる！というのはあんまりないです
- 武器・防具の概念がない
  - 最初っから最後まで装備は一緒です。アイテムで一時的に変更する以外、防御力を上げる手段は（把握している限り）ありません
- スタミナの概念がない
  - 忍者なので
  - 回避し放題、ダッシュし放題、攻撃し放題です
- 移動の自由度が圧倒的に高い
  - 鉤縄のおかげで、探索が非常に楽しいです。
- 致命の一撃を狙うのが基本
  - HPを削り切る、というパターンは多くないので、特に雑魚戦における戦闘のテンポが非常に早いです
- ソウルの回収的な要素がない
  - 死んだらそのタイミングできっちり経験値とかが半分になります
  - 救済措置はありますが、あんまり期待しないほうがいいです


要素としては色々ありますが、とにかくゲーム内の要素が *剣を交えること* に特化されている感じです。

*** キャラクターの成長＝自分の成長
Soulライクゲームでは、ある程度はレベルを上げてゴリ押し、ということができました。しかし、前述したとおり、SEKIROではレベルという概念がありません。アイテムを利用しないと、キャラクター自体の成長はありません。そして、そのアイテムは一部を除いて *ボスを倒さないと取得できません* 。

つまり、ボスで詰まった場合、 *自分自身の腕を上げないと攻略できません* 。ここでの腕は、相手のパターンを見切る、ということも含みます。この点がSoulライクゲームとの一番の相違でしょう。

逆に言うと、ボスに勝てた＝自分が成長した、ということにほかなりません。特に大ボスは、トドメにイベント的な最後の一撃が必要なんですが、それを行う＝勝利なので、イベント的な演出も含めて *勝利した瞬間の快感は凄まじいです* （個人差あり）。

その快感を得るために、次のボスに向かってまた何度も死ぬ・・・と繰り返すことになります。その過程で、ベースになる腕も上がっていきます。

*** *剣戟* を体感する
弾きと体幹システム上、基本的には攻め続けて、相手の攻撃は弾き（＝ジャストガード）し続ける、というのが理想です。そこに至るまでには何度も死ぬことになりますが・・・。逆に、そこに至ると、まさに映画のような剣戟を繰り広げることができます。これがまた気持ちいいんです。

相手がこちらの攻撃を弾き、相手の返す刀をこちらが弾き、また返す刀を浴びせる・・・という連鎖は、音ゲーのようにリズムを刻んでいく気持ちよさと通じるものがあります。この剣戟の気持ちよさ、というものもあり、あえて自ら攻撃に向かっていく、という原動力になります。まさに開発者の狙い通りになっている感じがしますが。

もちろん、敵もバラエティに富んでいるので、下手に剣戟を狙いに行くと逆に難易度が上がる、というケースもあります。そんなときは遠慮なく卑怯な戦法をとればいいんです。忍者ですから。

*** 回生システム
他のSoulライクゲームと違い、SEKIROでは死んでも一度だけ復活できます（正確ではないのですが、わかりやすいので）。復活までの時間制限付き（しばらく待っていると普通に死ぬ）ですが、後少しで倒せる、といったときには重宝します。

ただ、復活と言ってもHPは半分、その他は死ぬ前と同じなので、回復が切れていたときとかは、結局そのまま死ぬ、というケースも頻繁に起こります。実際には、相手のパターンを見切るための補助、というのが適当ではないかな？と思いました。

また、ゲーム中には *自殺用のアイテム* なるものも出てきます。忍者っぽい。私は結局利用しませんでしたが、これをあえて利用して回生システムを利用することで、回復の節約をする、ということもできるようです。そういった攻略にも、救済措置としても利用できる点で、このシステムも攻略の多様性に貢献しているのかな？と感じました。

*** 秀逸なレベルデザイン
色んなサイトで語られていますが、SEKIROのレベルデザインは秀逸の一言です。道中もボス戦も、最初は理不尽に見えたり感じたりするのが、一回二回と突破するたびに簡単になっていくのが肌でわかります。

道中では、最初はかなり過酷に思えたりしますが、いろいろ調べてルートを構築すると、驚くほどするりと行けるようになったりします。実はスルーできる、といったこともあります。道中でも死ぬことによるパターン構築、というのが基本ですが、ちゃんと一歩々々進んでいっている、という実感も得られるバランスになっています。

しかし、やはりボス戦のレベルデザインが秀逸です。一部を除くボスは、たいてい一戦目は驚くくらい死にます。私も一周目のラスボス戦とか、20回くらいから数えてませんでした。死ぬ中で徐々に相手を削れるようになり、まさに死闘の末に撃破、という形になるようになっています。

それが二戦目、三戦目ともなると、明らかに優位に進めていけるようになっていることに気づきます。極端な例だと、一周目で30回くらい死んだ大ボス戦が、二週目では一回しかダメージを喰らわなかった、といった具合に。
周回を重ねるたびに敵も強くなり、かつこちら側の体力は頭打ち（攻撃力だけは上がります）になっているにもかかわらず、自分の腕が上がっていることを周回ごとに実感できる・・・というのはかなり緻密な調整が必要であろうことは想像に難くありません。

*** 万人にはおすすめできないが、間違いない作品
- 難易度の高いアクションを操れるようになっていく実感
- ボスを倒したときの達成感
- 最適ルートを探していく楽しみ

など、難易度の高いアクションであることを全面的に押し出しつつも、ちゃんとクリアしていけるものであることと、戦闘そのものの楽しさなどから、個人的にはSEKIROは間違いなく名作だと思います。

かと言って万人受けするものでないことも確かです。あらゆるゲームにおいて、真に万人受けするものは存在しませんが、SEKIROは次の点からプレイする人を選ぶ作品だと思います。

- 救済措置がほぼない
  - 一回詰まるとなかなか抜けられないケースも
- じっくり考えて〜というものではなく、反射的な動作が求められる
  - RTS的なものとは判断を行う時間間隔が全く違います
  - 繰り返しプレイするしかなく、その過程では何度も挫折を味わいます
- カスタマイズ要素がない
  - 自分の好きなように、というのが狭いといえば狭いです。少なくとも、他のSoulライクゲームと比較すると、遊びの幅自体は狭いかと


他のSoulライクゲームをプレイしているのであれば、多少苦しんでもなんとかなるメンタルだと思いますが、メンタル的に合わない人は拒絶反応を起こしかねません。実際、SEKIROは難易度が高すぎるからEasy Modeをつけるべきだ、みたいな議論もあるようです。（なおHard modeはあります）

Easy modeをつける是非は、最終的には開発者側の判断でしょうが、今までのFROM Softwareを見る限り、そういったものをつけることはまずないでしょう。個人的にも必要性は感じませんし、SEKIROが表現したいんだろうなー、っていう物自体が薄れてしまうようにも感じます。そういった賛否両論があってこその名作だとも思います。

もし興味が出た方は、 *折れない心* を武器にして是非プレイしてみてください。折れても誰も助けてくれませんが・・・。

* comment Local Variables                                           :ARCHIVE:
# Local Variables:
# org-hugo-auto-export-on-save: t
# End:
