#+startup: content logdone inlneimages

#+hugo_base_dir: ../../../
#+hugo_auto_set_lastmod: t
#+HUGO_SECTION: post/2021/10
#+AUTHOR: derui

* DONE デスク環境を更新した                                            :雑記:
CLOSED: [2021-10-09 土 10:41]
:PROPERTIES:
:EXPORT_FILE_NAME: update_desk_environment
:END:
10月になっても半袖で十分というのはどうなんだ、と思いつつ、でもようやく涼しくなるようになってきました。

リモートワークでも生活でもずーっと使っているデスク環境を更新したので、その話を書こうかと思います。

<!--more-->

** 元々のデスク環境
さて、そもそも以前のデスクはどんな感じだったのかというと。

[[file:resized_before_desk_environment.jpg]]

こんな感じでした.これは実際にデスク周りを変更する直前なのでディスプレイとかは電源切ってます。


このデスクのスペックとデスクの上にあったものとして、

- デスク( ~幅160cm x 奥行60cm x 高さ70cm~ )
- ディスプレイ2枚
  - 27inch
- デスクトップスピーカー
- キーボード
- トラックボール
- コントローラー2個
- PS5
- ちょっとした物いれ


がありました。PS5は右のディスプレイの影になってますね。左端にちょこっと見えてる台みたいなやつは、デスクトップPCのキャリアです。

** 前の構成の課題
このデスクは前の部屋でも使っていたものを持ってきたやつですが、新しい部屋で使ううちに色々課題が生まれてきました。

- 左側のデッドスペースが気になる
  - デスクトップを入れているキャリアは、その上部空間がまるごと無駄になってます
- ゲームのコントローラーをしまう場所が無い
  - 別にいいんですが、いつまでも剥き出しというのも・・・
  - というかこのデスクは仕事でも使うので、これはこれでどうなん？という
- 上下のスペースが活用できていない
  - デスクの幅が160cmあるので、特に右側とかは上部に隙間がないという感じになってます。


これらの課題をどうしようかな、と考えてみました。

- デスクの幅が広すぎるので、もうちょっと狭くしても問題ない
  - 逆に、奥行がもうちょっとあってもよいかな、という考えにもなりました
  - iPadが置いてある辺に、通常はノートPCが置いてあるので、若干奥行が微妙だったりします
- 右にあるディスプレイをPC台の上に持っていく
  - 地震があったりするとちょっと怖いですが、エルゴトロンを信じて
- サイドデスク的なもので上下のスペースを活用する
  - PS5とかをデスクの上に載せないで、別に載せる感じで


後、デスクはまだリモートワークが続きそうでもある & 生活のほぼすべてがこの周辺なので、立ちながらとかできるように、電動昇降デスクを検討しました。
** 劇的After
さて、とりあえず更新してみました。

[[file:resized_after_desk_environment.jpg]]

ジャーン。ちなみにこれはまだ配置を調整している最中なので、現在はもうちょっと調整されてます。


更新ポイントは以下のような感じです。

- 憧れの電動昇降デスクにした
- サブデスクを導入した
- ディスプレイの配置を変更した
- スピーカーの位置を調整した


電動昇降デスクとサブデスクは↓にしました。サブデスクというかメタルラックなんですけど、ちょうどいいやつがこれくらいしかなかったんです。

デスクは、調べてみるとFlexiSpotを利用している・・・というのがかなり多かったので、最初はそれを検討してました。しかし、それらの記事をよく読むと、半分くらいが *FlexiSpotから提供を受けている* ということがわかりました。

これはマーケティングの一環として行われていることだとは思いますので、それ自体はよいのですが、実際それ以外のレビューを見ていると、サポートとかに課題がありそうだった & とてもいいお値段がするので、ちょっとどうしようかなぁ・・・、となってしまいました。

結局は、同等の機能があって一応国内メーカーである [[https://www.yamazen.co.jp/][山善]] 製のものを選択しました。

#+begin_quote
デスク全部合わせても椅子より安いんですけどね
#+end_quote

#+begin_export html
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=derui09-22&language=ja_JP&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=B077XC2VWH&linkId=217c9593ab5bae51716d4ebaa6363e9b"></iframe>
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=derui09-22&language=ja_JP&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=B082V8WYQS&linkId=a499c5936000a951845190498b9161c2"></iframe>
#+end_export

ちなみに電動昇降デスクは、大人二人で1時間〜1時間半くらいかかる、ということでしたが、実際に大人一人でやってみたところ、始めたのを若干後悔するくらい時間がかかりました。腰をやらなくてよかったです。

** で、どうなの？
まだ移行してから1日しか経過していませんが、左にあるマイクスタンドさえなんとかなれば・・・という感じです。現状ここ以外に置けないのですが、ここにあると左側のディスプレイがちょっと見えないんだけど・・・となってしまってます。

電動昇降デスクは、まだ数回しか昇降させてませんが、現状では特に問題なくきちんと動いています。立ちながら仕事、みたいなのは以前もやったことがありますが、立って仕事すると腕とキーボードがいい感じになるので、腕の疲れが若干軽減されますね。

** 定期的な見直しを
デスクというのは、プログラマーにとっては文字通り仕事に直結するものなので、やはり定期的な見直しは必要ですね。

でも電動昇降デスクを一人で組み立てるのは二度とやりません。超疲れた。

* DONE GraphQL + Kotlin + SpringBootの構成を試してみた(graphql-spring-boot-starter) :Kotlin:
CLOSED: [2021-10-24 日 11:56]
:PROPERTIES:
:EXPORT_FILE_NAME: graphql_kotlin_springboot_with_graphql-spring-boot-starter
:END:
仕事の方で、GraphQLをちょっと検討しだした + 個人的にも興味は持っていたので、本格的に触ってみることにしました。

GraphQLをKotlin + SpringBootで利用する方法としては、大きく三つありそうです。

- [[https://www.graphql-java-kickstart.com/spring-boot/][graphql-java-kickstar]]
- [[https://netflixtechblog.com/open-sourcing-the-netflix-domain-graph-service-framework-graphql-for-spring-boot-92b9dcecda18][Domain Graph Service]]
- [[https://docs.spring.io/spring-graphql/docs/current-SNAPSHOT/reference/html][Spring GraphQL]]


の三つがありそうです。どれもコアとしてはgraphql-javaを利用しているため、どのように統合するか？が焦点になっていますね。

#+begin_quote
Spring GraphQLは、記事の時点(2021/10)では1.0にむけてのマイルストーンを粛々と実装している、という状態です
#+end_quote

今回は、graphql-spring-boot-starterを利用してみた感想をば。なお、そもそもGraphQLとは？については、 [[https://graphql.org/][公式サイト]]を見ましょう。

<!--more-->

** セットアップ
さて、まずはセットアップ・・・なんですが、実はこのセットアップが大分苦戦しました。なぜかというと、2021/10時点で検索できる記事だと、結構古いパッケージ構造になっているケースが多く、色々動かない・・・というのがあったためです。

現状、

- graphql-java-tools
- graphql-spring-boot-starter
- graphql-java-servlet


といった関連は、すべて ~graphql-java-kickstart~ というGitHub Organizationにまとめられているので、こっちを使うのが第一になるかと。

#+begin_src text
  plugins {
      id("org.springframework.boot")
  }
  apply(plugin = "io.spring.dependency-management")
  
  dependencies {
      implementation("org.springframework.boot:spring-boot-starter-web")
      implementation("com.graphql-java-kickstart:graphql-spring-boot-starter:12.0.0")
      implementation("com.graphql-java-kickstart:graphql-java-tools:12.0.0")
  }
  
#+end_src

最小構成だと↑のような感じになります。バージョンなどはよしなに。

** schemaとのマッピング
graphql-java-toolsを利用するかしないか、で大分書きかたが異なりますが、基本的にはgraphql-spring-boot-starterを利用する場合は併用しておいた方がよさそうです。

GitHubにも書いていますが、必要なら↓のようなpropertiesを追記します。

#+begin_src text
  graphql:
    tools:
      schema-location-pattern: "**/*.graphqls"
      # Enable or disable the introspection query. Disabling it puts your server in contravention of the GraphQL
      # specification and expectations of most clients, so use this option with caution
      introspection-enabled: true
#+end_src

さて、マッピングについてはgraphql-java-toolsに準ずるので、Queryに関しては結構シンプルに書くことができます。

- ~GraphQLQueryResolver~ を実装する
  - これはRoot Queryに相当
- ~GraphQLResolver<Data>~ を実装する
  - ~Data~ のクラスに対応するResolverを実装する


という感じです。基本的にはGraphQLのschemaと名前が一致している必要があり、それを基本的に変更することはできません。
これはSpring GraphQLでも基本的に同じような路線(向こうはどっちかというとアノテーションベースですが)のようです。

*** サンプル
以下のようなGraphQLのschemaがあった場合、

#+begin_src graphql
  type Query {
    messages: [Message!]!
  }
  
  type Message {
    id: ID!
    message: String!
  }
#+end_src

以下のようなResolverでマッピングできます。

#+begin_src kotlin
  data class Message(val id: String, val message: String)
  
  class Query: GraphQLQueryResolver {
    fun messages(): List<Messaage> {
      return emptyList()
    }
  }
#+end_src

emptyListのあたりは如何様にでもできます。このResolverを実装したら、これをSchemaParserというクラスに渡す必要があります。


#+begin_src kotlin
  @SpringBootApplication
  class GraphqlApp {
  
      @Bean
      fun schemaParser(): SchemaParser {
          return SchemaParser.newParser()
              .files("sample.graphqls")
              .resolvers(Query())
              .build()
      }
  }
  
  fun main(args: Array<String>) {
      SpringApplication.run(GraphqlApp::class.java, *args)
  }
#+end_src

このようにすることで、 ~/graphql~ エンドポイントからアクセスすることができます。

** カスタムコンテキスト
graphql-javaにはGraphQLContextという形で、DataFetcher(graphql-javaが提供しているデータ取得の仕組み)からコンテキストを取得することができます。

例えば認証したユーザーの情報とかを使いたい場合、このコンテキストに渡すことで、そのリクエスト全体で利用することができます。

まず、カスタムコンテキストですが、推奨されている方法としては ~GraphQLContext::put~ などで設定して利用する、という形です。このGraphQLContextに設定するタイミングは、 ExecutionInputという実行処理に対する入力を生成するタイミングとなっています。

graphql-java-toolsでも https://www.graphql-java-kickstart.com/tools/schema-parser-options/ でそのように記載しています。

・・・が、現時点のgraphql-spring-boot-starterではちょっとここに課題があります。

graphql-java-servletで提供している仕組みとして、 ~GraphQLServletContextBuilder~ というものがあります。これは、GraphQLContextインターフェース(とてつもなくややこしいですが、こっちはgraphql-javaのGraphQLContextとは別物です)を実装したコンテキストをこのBuilderから返すことで、GraphQLContextに渡せる・・・というように読めます。

#+begin_src kotlin
  class MockContext(
      dataLoaderRegistry: DataLoaderRegistry? = null,
  ) : GraphQLContext {
      private val dataLoaderRegistry = dataLoaderRegistry ?: DataLoaderRegistry()
  
      fun bark() = "foo"
  
      override fun getSubject(): Optional<Subject> {
          return Optional.empty()
      }
  
      override fun getDataLoaderRegistry(): DataLoaderRegistry {
          return dataLoaderRegistry
      }
  }
  
  @Component
  class CoreGraphQLServletContextBuilder(
      private val companyService: CompanyService
  ) : GraphQLServletContextBuilder {
      override fun build(
          httpServletRequest: HttpServletRequest,
          httpServletResponse: HttpServletResponse
      ): GraphQLContext {
          return MockContext()
      }
  
      override fun build(session: Session?, handshakeRequest: HandshakeRequest?): GraphQLContext {
          TODO("Not yet implemented")
      }
  
      override fun build(): GraphQLContext {
          return MockContext()
      }
  }
  
#+end_src

こいつは ~graphql-spring-boot-starter~ のautoconfigureから拾われて利用される・・・んですが、ここで生成されたcontextは、 *GraphQLContext::getから取得できません* 。
ではどこから取得するのかというと、 ~DataFetchingEnvironment::getContext~ が、返却したcontextそのものになっています。

しかし、この ~DataFetchingEnvironment::getContext~ 自体が最新のgraphql-javaではdeprecatedになっており、かつgraphql-java-toolsでも警告を出すような処理になっています。

#+begin_quote
試していたときに、なんでここで取れないんだろう・・・ってしばらくデバッグやソースを読んだりしてました
#+end_quote

コミュニティ的に完全にリソースが足りていないので、中々是正が大変そうですが・・・。

** GraphQLをテストする
graphql-spring-boot-starterでは、 [[https://github.com/graphql/graphiql][graphiql]]を組み込みで利用できる・・・んですが、組み込み先のプロジェクトの設定とかと素敵にバッティングすると、利用するまでがとてつもなく長くなったりします。

手っ取り早い方法としてgraphiqlのElectron版があるので、これを利用すればとりあえずしのげます。

GraphQLは細かいDataFetcherなどを統合していく・・・という形になっているので、基本的にはこれらの単体をテストしていけばよさそうかなーとは思っています。

** 他のライブラリも試したい
まだ本当にPoC的に触っただけなので、これ以上書けることが無いという。

graphql-java-toolsが若干の前提にはなりますが、CoCに従って実装するというのはわりとわかりやすく、またマッピングについてはきちんとドキュメントに書いているので、単純に書く分には結構問題ありません。

が、バラバラのlibraryを統合している都合上、どこかチグハグ感もあります。しかし、関連ライブラリでは最も広く利用されているので、最初に選択肢として選ぶには問題ないと思います。

ちょっと次はNetflixのDGSを利用してみようかなー、と思います。

* comment Local Variables                                           :ARCHIVE:
# Local Variables:
# eval: (org-hugo-auto-export-mode)
# End:
